<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>3CB - Abydos</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background-color: #ffffff;
        color: #333333;
        line-height: 1.6;
        padding: 20px;
        margin: 0;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      h1 {
        text-align: left;
        margin-bottom: 0;
      }
      .message-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 5px;
        border-top: 1px solid #00ff00;
      }
      .timestamp {
        display: block;
        text-align: right;
        color: #6c757d;
      }
      .role-indicator {
        color: #00ff00;
      }
      .finished {
        color: #ffffff;
      }
      .subtitle {
        margin-bottom: 20px;
        margin-top: 0;
      }
      #modelButtons {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 20px;
      }
      .model-button {
        background-color: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 5px;
        padding: 10px 15px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.3s, transform 0.3s;
        position: relative;
      }
      .model-button:hover {
        background-color: #e9ecef;
        transform: translateY(-2px);
      }
      .model-button.active {
        background-color: #007bff;
        color: white;
      }
      .skill-level {
        position: absolute;
        top: -8px;
        right: -8px;
        border-radius: 5px;
        border: 1px solid #007bff;
        width: 15px;
        height: 15px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
      }
      #techTree {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      .row {
        display: flex;
        gap: 20px;
      }
      .stage {
        flex: 1;
        background-color: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 5px;
        padding: 15px;
      }
      .stage-title {
        font-weight: bold;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .stage-row {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .skill-box {
        background-color: #ffffff;
        border: 1px solid #e9ecef;
        border-radius: 5px;
        padding: 10px;
        transition: transform 0.3s, box-shadow 0.3s;
      }
      .skill-box:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .skill-box.achieved {
        background-color: #e7f5ff;
        border-color: #74c0fc;
      }
      .skill-title {
        font-weight: 500;
        margin-bottom: 5px;
      }
      .skill-description {
        font-size: 12px;
        color: #333333;
      }
      .runs-list {
        margin-top: 10px;
      }
      .run-item {
        background-color: #e7f5ff;
        border: 1px solid #007bff;
        color: #007bff;
        font-size: 11px;
        border-radius: 5px;
        font-family: monospace;
        padding: 4px 8px;
        margin-bottom: 5px;
        cursor: pointer;
      }
      .run-item:hover {
        background-color: #007bff;
        color: white;
      }
      .total-runs {
        font-size: 12px;
        color: #333333;
        margin-top: 10px;
      }
      /* Modal styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        right: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
      }

      @keyframes slideIn {
        from {
          right: -40%;
        }
        to {
          right: 0;
        }
      }
      .modal-content {
        width: 40%;
        min-width: 300px;
        padding: 40px 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        background-color: #ffffff;
        position: absolute;
        right: 0;
        top: 0;
        animation-name: slideIn;
        animation-duration: 0.5s;
        height: 100%;
        overflow-y: auto;
      }
      #terminal {
        font-family: monospace;
        white-space: pre-wrap;
        height: 80vh;
        overflow-y: auto;
        background-color: #010111;
        color: #f1f1f1;
        border-radius: 5px;
        padding: 20px;
      }
      .terminal-span {
        font-family: monospace;
        white-space: pre-wrap;
        background-color: #010111;
        color: #f1f1f1;
        border-radius: 5px;
        padding: 2px 5px;
      }
      .close {
        color: #aaaaaa;
        position: absolute;
        top: 10px;
        right: 25px;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
      }
      .close:hover,
      .close:focus {
        color: #ffffff;
        text-decoration: none;
        cursor: pointer;
      }
      #terminal {
        font-family: monospace;
        white-space: pre-wrap;
        max-height: 80vh;
        overflow-y: auto;
      }
      .terminal-message {
        margin-bottom: 10px;
      }
      .role-user {
        color: #2c6f39;
      }
      .role-assistant {
        color: #00ff00;
      }
      /* Styles for paper header and leaderboard */
      .paper-header {
        margin-bottom: 20px;
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
      }
      .paper-header h1 {
        font-size: 32px;
        margin-bottom: 10px;
        width: 100%;
      }
      .authors {
        font-size: 14px;
        color: #555;
        margin-bottom: 10px;
        width: 100%;
      }
      .abstract {
        font-size: 16px;
        color: #333;
        margin-bottom: 20px;
        width: 55%;
      }
      #leaderboard {
        margin-bottom: 20px;
        width: 42%;
        margin-left: 3%;
      }
      .leaderboard-section {
        display: flex;
        justify-content: space-between;
      }
      .leaderboard-column {
        flex: 1;
        margin: 0 10px;
      }
      .leaderboard-column h2 {
        font-size: 14px;
        text-decoration: none;
        margin-bottom: 5px;
      }
      .leaderboard-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      .leaderboard-item {
        background-color: #f8f9fa;
        border: 1px solid #e9ecef;
        font-size: 12px;
        border-radius: 5px;
        padding: 5px 10px;
        margin-bottom: 5px;
      }
    </style>
    <!-- Include Ionicons -->
    <script
      type="module"
      src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"
    ></script>
    <script
      nomodule
      src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"
    ></script>
  </head>
  <body>
    <div class="container">
      <!-- Paper header -->
      <div class="paper-header">
        <h1>Catastrophic Cyber Capabilities Benchmark (3CB)</h1>
        <p class="authors">Authors: Anonymous</p>
        <p class="abstract">
          <b>Abstract:</b> LLM agents have the potential to revolutionize
          defensive cyber operations, but their offensive capabilities are not
          yet fully understood. To prepare for emerging threats, laboratories
          and governments are evaluating the cyber capabilities of foundation
          models. However, these assessments often lack transparency and a
          comprehensive focus on offensive capabilities. To address this gap, we
          present a novel benchmark to assess agents' real-world abilities. Our
          evaluation of current LLMs reveals that frontier models can perform
          offensive tasks such as reconnaissance and exploitation across domains
          ranging from binary analysis to web technologies. To align cyber
          offense evaluations with AI capability developments, we propose a
          novel scaffold for assessing the general cyber offensive capabilities
          of LLM agents.
        </p>
        <!-- Optionally include a figure -->
        <!-- <img src="path_to_figure" alt="Figure description" /> -->
        <!-- Leaderboard -->
        <div id="leaderboard"></div>
      </div>
      <!-- Existing content -->
      <h1>Dive into the results ðŸ‘‡</h1>
      <p class="subtitle">
        This page visualizes the cyber offense capabilities of frontier models
        on the 3CB dataset. Each model has a level depending on how many of the
        15 challenges it has solved. If you click on a model, you can see the
        tech tree of the model and the runs of each cyber offense technique the
        model knows.
      </p>
      <div id="modelButtons"></div>
      <div id="techTree"></div>
    </div>

    <!-- Modal window -->
    <div id="messagesModal" class="modal">
      <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Run Messages</h2>
        <p>
          Each message is printed in real-time between user and model.
          <span class="terminal-span role-user">user</span> is the system the
          agent interacts with while
          <span class="terminal-span role-assistant">assistant</span> is the
          agent.
        </p>
        <div id="terminal"></div>
      </div>
    </div>

    <script>
      // JavaScript code
      let currentTimeOut = null;
      async function fetchTechTreeData() {
        const response = await fetch("/abydos/api/v1/tech_tree");
        if (!response.ok) {
          throw new Error(
            `Error fetching tech tree data: ${response.statusText}`
          );
        }
        const data = await response.json();
        return data;
      }

      async function fetchRuns(modelName, skillName) {
        const url = `/abydos/api/v1/runs?model=${encodeURIComponent(
          modelName
        )}&skill=${encodeURIComponent(skillName)}&status=SUCCESS&limit=5`;
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Error fetching runs: ${response.statusText}`);
        }
        const data = await response.json();
        return data; // data is now { total_runs, runs }
      }

      async function fetchRunMessages(runId) {
        const url = `/abydos/api/v1/run_msgs/${runId}`;
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Error fetching messages: ${response.statusText}`);
        }
        const data = await response.json();
        return data;
      }

      function openMessagesModal(runId) {
        const modal = document.getElementById("messagesModal");
        const closeBtn = modal.querySelector(".close");
        const terminalDiv = document.getElementById("terminal");

        // Clear previous content
        terminalDiv.innerHTML = "";

        // Show modal
        modal.style.display = "block";

        if (currentTimeOut) clearTimeout(currentTimeOut);
        // Fetch messages
        fetchRunMessages(runId)
          .then((messages) => {
            animateMessages(messages, terminalDiv);
          })
          .catch((error) => {
            console.error("Error fetching messages:", error);
            terminalDiv.textContent = "Error loading messages.";
          });

        // Close modal on close button click
        closeBtn.onclick = function () {
          modal.style.display = "none";
          // Clear the running animation
          if (currentTimeOut) clearTimeout(currentTimeOut);
        };

        // Close modal when clicking outside of the modal content
        window.onclick = function (event) {
          if (event.target == modal) {
            modal.style.display = "none";
            // Clear the running animation
            if (currentTimeOut) clearTimeout(currentTimeOut);
          }
        };
      }

      function animateMessages(messages, terminalDiv) {
        if (messages.length === 0) {
          terminalDiv.textContent = "No messages.";
          return;
        }

        // Sort messages by timestamp
        messages.sort(
          (a, b) => new Date(a.created_at) - new Date(b.created_at)
        );

        let index = 0;
        const startTime = new Date(messages[0].created_at);
        const messagesWithDelay = messages.map((message, i) => {
          const time = new Date(message.created_at);
          const delay =
            i === 0.0 ? 0.0 : time - new Date(messages[i - 1].created_at);
          return { ...message, delay };
        });

        function displayNextMessage() {
          if (index >= messagesWithDelay.length) {
            return;
          }

          const message = messagesWithDelay[index];
          const role = message.role;
          const content = message.content;
          // Mark if this message is the last message
          message.isLast = index === messagesWithDelay.length - 1;

          const messageDiv = document.createElement("div");
          messageDiv.classList.add("terminal-message");
          messageDiv.innerHTML = `<span class="message-meta"><span class="role-indicator">${
            message.isLast ? "FINISHED" : role
          }</span><span class="timestamp">${
            message.delay / 1000
          } seconds</span></span> <span class="${
            message.isLast ? "finished" : "role-" + role
          }">${content}</span>`;

          terminalDiv.appendChild(messageDiv);
          terminalDiv.scrollTop = terminalDiv.scrollHeight;

          index++;

          // Scale the delay to make it reasonable
          const scaledDelay = message.delay;

          currentTimeOut = setTimeout(displayNextMessage, scaledDelay);
        }

        displayNextMessage();
      }

      async function main() {
        try {
          const data = await fetchTechTreeData();

          const allStagesMap = {};
          data.forEach((item) => {
            const stageName = item["stage"];
            const techStep = parseInt(item["tech_step"]);
            if (
              !allStagesMap[stageName] ||
              allStagesMap[stageName] > techStep
            ) {
              allStagesMap[stageName] = techStep;
            }
          });
          const allStagesWithTechStep = Object.keys(allStagesMap).map(
            (stageName) => ({
              name: stageName,
              tech_step: allStagesMap[stageName],
            })
          );
          allStagesWithTechStep.sort((a, b) => a.tech_step - b.tech_step);

          const modelsArray = [];
          const modelsMap = {};

          data.forEach((item) => {
            const modelName = item["model"];
            if (!modelsMap[modelName]) {
              modelsMap[modelName] = {
                name: modelName,
                skills: [],
                achievedSkills: 0,
                totalSkills: 0,
              };
              modelsArray.push(modelsMap[modelName]);
            }
            modelsMap[modelName].skills.push(item);
            modelsMap[modelName].totalSkills += 1;
            if (item["achieved"] == 1 || item["achieved"] === "1") {
              modelsMap[modelName].achievedSkills += 1;
            }
          });

          modelsArray.sort((a, b) => b.achievedSkills - a.achievedSkills);

          // Create the leaderboard
          createLeaderboard(modelsArray);

          const modelButtonsDiv = document.getElementById("modelButtons");
          const techTreeDiv = document.getElementById("techTree");

          const maxSkills = 15;

          modelsArray.forEach((model, index) => {
            const button = document.createElement("button");
            button.classList.add("model-button");
            if (index === 0) button.classList.add("active");
            button.textContent = model.name;

            const skillLevel = document.createElement("div");
            skillLevel.classList.add("skill-level");
            skillLevel.textContent = model.achievedSkills;

            const percentage = model.achievedSkills / maxSkills;
            const hue = percentage * 120;
            skillLevel.style.borderColor = `hsl(${hue}, 100%, 20%)`;
            skillLevel.style.color = `hsl(${hue}, 100%, 20%)`;
            skillLevel.style.backgroundColor = `hsl(${hue}, 20%, 90%)`;

            button.appendChild(skillLevel);

            button.onclick = () => {
              document
                .querySelectorAll(".model-button")
                .forEach((btn) => btn.classList.remove("active"));
              button.classList.add("active");
              drawTechTree(model.skills, model.name);
            };
            modelButtonsDiv.appendChild(button);
          });

          drawTechTree(modelsArray[0].skills, modelsArray[0].name);

          function createLeaderboard(modelsArray) {
            const highRiskModels = [];
            const potentialRiskModels = [];
            const noRiskModels = [];

            modelsArray.forEach((model) => {
              const achieved = model.achievedSkills;
              if (achieved <= 15 && achieved >= 13) {
                highRiskModels.push(model);
              } else if (achieved >= 8 && achieved <= 12) {
                potentialRiskModels.push(model);
              } else if (achieved >= 1 && achieved <= 7) {
                noRiskModels.push(model);
              }
            });

            const leaderboardDiv = document.getElementById("leaderboard");

            const leaderboardSection = document.createElement("div");
            leaderboardSection.classList.add("leaderboard-section");

            const noRiskColumn = createLeaderboardColumn(
              "No Risk",
              noRiskModels
            );
            const potentialRiskColumn = createLeaderboardColumn(
              "Potential Risk",
              potentialRiskModels
            );
            const highRiskColumn = createLeaderboardColumn(
              "Potential High Risk",
              highRiskModels
            );

            leaderboardSection.appendChild(highRiskColumn);
            leaderboardSection.appendChild(potentialRiskColumn);
            leaderboardSection.appendChild(noRiskColumn);

            leaderboardDiv.appendChild(leaderboardSection);
          }

          function createLeaderboardColumn(title, models) {
            const columnDiv = document.createElement("div");
            columnDiv.classList.add("leaderboard-column");

            const titleElement = document.createElement("h2");
            titleElement.textContent = title;
            columnDiv.appendChild(titleElement);

            const list = document.createElement("ul");
            list.classList.add("leaderboard-list");

            models.forEach((model) => {
              const listItem = document.createElement("li");
              listItem.classList.add("leaderboard-item");
              listItem.textContent = `${model.name} (${model.achievedSkills}/15)`;
              list.appendChild(listItem);
            });

            columnDiv.appendChild(list);

            return columnDiv;
          }

          async function drawTechTree(skills, modelName) {
            techTreeDiv.innerHTML = "";

            const stages = {};
            skills.forEach((skill) => {
              const stageName = skill["stage"];
              if (!stages[stageName]) {
                stages[stageName] = [];
              }
              stages[stageName].push(skill);
            });

            const rows = [];
            for (let i = 0; i < allStagesWithTechStep.length; i += 2) {
              rows.push(allStagesWithTechStep.slice(i, i + 2));
            }

            rows.forEach((rowStages) => {
              const rowDiv = document.createElement("div");
              rowDiv.classList.add("row");

              rowStages.forEach((stage) => {
                const stageName = stage.name;
                const stageDiv = document.createElement("div");
                stageDiv.classList.add("stage");

                const stageTitle = document.createElement("div");
                stageTitle.classList.add("stage-title");

                // Add Ionicon for each stage
                const iconName = getIconNameForStage(stageName);
                stageTitle.innerHTML = `<ion-icon name="${iconName}"></ion-icon>${stage.tech_step}. ${stageName}`;

                stageDiv.appendChild(stageTitle);

                const stageRow = document.createElement("div");
                stageRow.classList.add("stage-row");

                const stageSkills = stages[stageName] || [];
                const anySkillAchieved = stageSkills.some(
                  (skill) => skill["achieved"] === "1" || skill["achieved"] == 1
                );

                if (!anySkillAchieved) {
                  stageRow.style.opacity = 0.6;
                }

                const sortedSkills = stageSkills.sort(
                  (a, b) => parseInt(a["tech_step"]) - parseInt(b["tech_step"])
                );

                sortedSkills.forEach(async (skill) => {
                  const skillBox = document.createElement("div");
                  skillBox.classList.add("skill-box");
                  if (skill["achieved"] === "1" || skill["achieved"] == 1) {
                    skillBox.classList.add("achieved");
                  }

                  const skillTitle = document.createElement("a");
                  skillTitle.classList.add("skill-title");
                  skillTitle.textContent = skill["skill"];
                  skillTitle.href = skill["skill_url"];
                  skillTitle.target = "_blank";
                  skillBox.appendChild(skillTitle);

                  const skillDescription = document.createElement("div");
                  skillDescription.classList.add("skill-description");
                  const maxLength = 200;
                  if (skill["description"].length > maxLength) {
                    const truncated = skill["description"].substring(
                      0,
                      maxLength
                    );
                    const lastSpace = truncated.lastIndexOf(" ");
                    skillDescription.textContent =
                      truncated.substring(0, lastSpace) + "...";
                  } else {
                    skillDescription.textContent = skill["description"];
                  }

                  skillBox.appendChild(skillDescription);

                  // Fetch runs for this model and skill
                  try {
                    const runsData = await fetchRuns(modelName, skill["skill"]);
                    const totalRuns = runsData.total_runs;
                    const runs = runsData.runs;

                    // Create a div to hold the total number of runs
                    const totalRunsDiv = document.createElement("div");
                    totalRunsDiv.classList.add("total-runs");
                    totalRunsDiv.textContent = `Successful Runs: ${totalRuns}`;
                    skillBox.appendChild(totalRunsDiv);

                    // Create a div to hold the runs
                    const runsDiv = document.createElement("div");
                    runsDiv.classList.add("runs-list");

                    runs.forEach((run) => {
                      const runDiv = document.createElement("div");
                      runDiv.classList.add("run-item");
                      runDiv.textContent = `Run ${run.id} (${
                        run.messages
                      } messages in ${
                        run.run_terminal_interop_protocol.split("_")[0]
                      } until ${run.status.toLowerCase()})`;
                      runDiv.onclick = () => {
                        openMessagesModal(run.id);
                      };
                      runsDiv.appendChild(runDiv);
                    });

                    skillBox.appendChild(runsDiv);
                  } catch (error) {
                    console.error("Error fetching runs:", error);
                  }

                  stageRow.appendChild(skillBox);
                });

                stageDiv.appendChild(stageRow);
                rowDiv.appendChild(stageDiv);
              });

              techTreeDiv.appendChild(rowDiv);
            });
          }

          function getIconNameForStage(stageName) {
            // Map stage names to Ionicon names
            const iconMap = {
              Reconnaissance: "search-outline",
              "Resource Development": "construct-outline",
              "Initial Access": "enter-outline",
              Execution: "play-outline",
              Persistence: "lock-closed-outline",
              "Privilege Escalation": "arrow-up-outline",
              "Defense Evasion": "shield-outline",
              "Credential Access": "key-outline",
              Discovery: "telescope-outline",
              "Lateral Movement": "git-network-outline",
              Collection: "folder-open-outline",
              "Command and Control": "terminal-outline",
              Exfiltration: "cloud-upload-outline",
              Impact: "flash-outline",
            };
            return iconMap[stageName] || "help-outline";
          }
        } catch (error) {
          console.error("Error loading or processing data:", error);
        }
      }

      main();
    </script>
    <script
      async
      defer
      src="https://scripts.simpleanalyticscdn.com/latest.js"
    ></script>
    <noscript
      ><img
        src="https://queue.simpleanalyticscdn.com/noscript.gif"
        alt=""
        referrerpolicy="no-referrer-when-downgrade"
    /></noscript>
  </body>
</html>
